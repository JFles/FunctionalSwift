import UIKit

//: # Ch 9 - Case Study: Diagrams
//:
//: In this chapter, we'll look at a functional way to describe diagrams and discuss how to draw them with Core Graphics. By wrapping Core Graphics with a functional layer, we get an API that's simpler and more composable.
//:
//: ## Drawing Squares and Circles
//:
//: First, lets consider how we would draw a simple diagram in Core Graphics
let bounds = CGRect(origin: .zero, size: CGSize(width: 300, height: 200))
let renderer = UIGraphicsImageRenderer(bounds: bounds)
renderer.image { context in
    UIColor.blue.setFill()
    context.fill(CGRect(x: 0.0, y: 37.5, width: 75.0, height: 75.0))
    UIColor.red.setFill()
    context.fill(CGRect(x: 75.0, y: 0.0, width: 150.0, height: 150.0))
    UIColor.green.setFill()
    context.cgContext.fillEllipse(in: CGRect(x: 225.0, y: 37.5, width: 75.0, height: 75.0))
}
//: This is easy and short code, but it would be difficult to maintain
//:
//: For example, lets say we wanted to insert an extra circle in our diagram between two existing shapes. We'd need to add code for drawing our new circle, and we'd need to adjust our doubles for coordinates to shift our shapes to the right.
//:
//: Core Graphics is an imperative library by design -- we describe **how** to draw things.
//:
//: Our goal in this chapter is to build a library to wrap Core Graphics for diagrams which instead allows us to declaratively describe **what** to draw
//:
//: For example, we could use our declarative wrapper library to rewrite the first example as follows
let blueSquare = square(size: 1).filled(.blue)
let redSquare = square(size: 2).filled(.red)
let greenCircle = circle(diameter: 1).filled(.green)
let example1 = blueSquare ||| redSquare ||| greenCircle
//: And adding our new circle would be trivially easy
let cyanCircle = circle(diameter: 1).filled(.cyan)
let example1 = blueSquare ||| cyanCircle ||| redSquare ||| greenCircle
//: We no longer need to worry about calculating frames or moving coordinates. Instead, we can focus on **_what_** should be drawn, and **_how_** it's drawn is abstracted away from us.

//: Looking back at Ch 1, we constructed regions by composing simple functions. While this helped to illustrate FP concepts, there was a large drawback -- We couldn't inspect **_how_** a region had been constructed. Instead, we could only check whether or not a point was included in the region.
//:
//: In this chapter, we'll improve this aspect
//:
//: Instead of immediately executing our drawing commands, we'll build an intermediate data structure which describes the diagram.
//: This is a very powerful technique -- it allows us to inspect the data structure, modify it, and convert it into different formats.

//: As a more complex example of a diagram generated by our same library, let's create a bar graph.
//:
//: We can write a `barGraph` function that takes a list of names (the keys) and values (the relative heights of the bars). For each value in the dictionary, we draw a suitably sized rectangle. We then horizontally concatenate the rectangles with the `hcat` method. Finally, we put the bars and the text below each other using our custom `---` operator.
func barGraph(_ input: [(String, Double)]) -> Diagram {
    let values: [CGFloat] = input.map { CGFloat($0.1) }
    let bars = values
        .normalized // values are normalized so that our largest value == 1 -- easier if we're bound between `0 <= x <= 1`
        .map { x in rect(width: 1, height: 3 * x).filled(.black).aligned(to: .bottom) }
        .hcat // This name is terrible ðŸ’© -- unless it represents a standardly used declarative function operator, it should be expanded
    let labels = input
        .map { label, _ in text(label, width: 1, height: 0.3).aligned(to: .top) }
        .hcat
    return bars --- labels // `---` infix operator lays out our `labels` beneath our `bars`
}



//: [Previous](@previous)          [Next](@next)
